<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>鸣谢名单</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <style>
            :root{
                --swipe-duration: 700ms;
                --entry-duration: 1000ms;
            }
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #f0f0f0;
            }
            .container {
                max-width: 800px;
                margin: 50px auto;
                padding: 20px;
                background-color: #fff;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            }
            h1 { color: #4CAF50; }
            .th { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
            .th2 {
                padding: 10px 15px;
                background-color: #e7f3e7;
                border: 1px solid #4CAF50;
                border-radius: 5px;
                text-decoration: none;
                color: #4CAF50;
                font-weight: bold;
                transition: background-color 0.3s, color 0.3s;
            }
            .th2:hover { background-color: #4CAF50; color: #fff; }

            /* markdown 渲染样式 */
            .md-content { color:#222; line-height:1.7; }
            .md-content h1,.md-content h2 { color:#103c12; }
            .md-content pre { background:#0b0b0b; color:#f8f8f2; padding:12px; border-radius:8px; overflow:auto; }
            .md-content code { background:#f4f4f4; padding:2px 6px; border-radius:6px; font-family:monospace; }
            .md-content img { max-width:100%; height:auto; display:block; margin:10px 0; border-radius:6px; }
        </style>

        <!-- 预连接 CDN 提速（减少 DNS/TCP 握手） -->
        <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
        <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
        <!-- 可预加载常用图片以避免首次渲染闪烁（如有 logo） -->
        <link rel="preload" href="assets/images/entry-logo.png" as="image">
        <!-- EXTERNAL SCRIPTS: 移至 body 底部并使用 defer（不阻塞首屏） -->
    </head>
    <body>
        <div class="container">
            <h1 class="green">鸣谢名单</h1>

            <div class="th">
                <a href="index.html" class="qblue th2" data-transition="swipe" ><i class="fa-solid fa-house"></i> 返回主页</a>
            </div>

            <!-- md 渲染容器 -->
            <div id="mdContainer" class="md-content" aria-live="polite">
                <!-- ...existing code... -->
                <p>正在加载名单……</p>
                <!-- ...existing code... -->
            </div>
        </div>

        <!-- 将外部 lib 放到文档尾部并使用 defer，以免阻塞渲染 -->
        <script>
        (function () {
            // 支持本地候选与可配置的云端 URL（若需云端请在 <head> 加：<meta name="md-remote" content="https://raw.githubusercontent.com/.../名单.md">）
            const localCandidates = ['名单.md','credits.md','list.md'];
            const remoteMeta = document.querySelector('meta[name="md-remote"]');
            const remoteCandidates = remoteMeta ? [remoteMeta.content] : (window.MD_REMOTE_URLS || []);
            const candidates = [...remoteCandidates, ...localCandidates];

            const out = document.getElementById('mdContainer');
            const CACHE_TTL = 24 * 60 * 60 * 1000; // 缓存有效期（ms）
            const FETCH_TIMEOUT = 7000;

            function showMsg(html, level = 'warn') {
                out.innerHTML = `<div style="color:${level==='err'?'#b33':'#b86'};margin:14px 0">${html}</div>`;
                console[level === 'err' ? 'error' : 'warn'](html);
            }

            function loadScript(src, timeout = 7000) {
                return new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    let done = false;
                    s.src = src; s.async = true;
                    s.onload = () => { if (!done) { done = true; resolve(); } };
                    s.onerror = () => { if (!done) { done = true; reject(new Error('load failed: ' + src)); } };
                    document.head.appendChild(s);
                    setTimeout(() => { if (!done) { done = true; reject(new Error('timeout: ' + src)); } }, timeout);
                });
            }

            function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

            // 简单回退解析器（保留原函数）
            function simpleMdToHtml(md) {
                let codeBlocks = [];
                md = md.replace(/```([\s\S]*?)```/g, (m, p1) => {
                    const idx = codeBlocks.push(escapeHtml(p1)) - 1;
                    return `\n@@CODEBLOCK${idx}@@\n`;
                });
                const lines = md.split(/\r?\n/);
                let html = ''; let inList = false;
                lines.forEach(line => {
                    if (/^\s*[-*+]\s+/.test(line)) {
                        if (!inList) { inList = true; html += '<ul>'; }
                        const item = line.replace(/^\s*[-*+]\s+/, '');
                        html += '<li>' + inlineTransform(item) + '</li>'; return;
                    } else { if (inList) { html += '</ul>'; inList = false; } }
                    const h = line.match(/^(#{1,6})\s+(.*)/);
                    if (h) { html += `<h${h[1].length}>` + inlineTransform(h[2]) + `</h${h[1].length}>`; return; }
                    if (/^(-{3,}|\*{3,}|_{3,})\s*$/.test(line)) { html += '<hr/>'; return; }
                    if (/^\s*$/.test(line)) { html += ''; return; }
                    html += `<p>${inlineTransform(line)}</p>`;
                });
                if (inList) html += '</ul>';
                html = html.replace(/@@CODEBLOCK(\d+)@@/g, (m, idx) => {
                    const code = codeBlocks[Number(idx)] || '';
                    return `<pre><code>${code}</code></pre>`;
                });
                return html;

                function inlineTransform(text) {
                    text = escapeHtml(text);
                    text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (m, alt, url) => `<img src="${escapeAttr(url)}" alt="${escapeAttr(alt)}">`);
                    text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, t, u) => `<a href="${escapeAttr(u)}" target="_blank" rel="nofollow noopener noreferrer">${t}</a>`);
                    text = text.replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`);
                    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                    text = text.replace(/(^|[^*])\*([^*]+)\*([^*]|$)/g, (m,a,b,c) => `${a}<em>${b}</em>${c}`);
                    return text;
                }
                function escapeAttr(s){ return s.replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
            }

            // 存储 key helpers（对 URL 做可逆 key）
            function keyFor(url) { return 'md:' + encodeURIComponent(url); }
            function metaKeyFor(url){ return keyFor(url) + ':meta'; }
            function htmlKeyFor(url){ return keyFor(url) + ':html'; }

            // 立即显示缓存（快速感知）
            (function immediateCacheShow() {
                for (const c of candidates) {
                    const key = keyFor(c);
                    try {
                        const rawHtml = localStorage.getItem(htmlKeyFor(c));
                        if (rawHtml) {
                            const obj = JSON.parse(rawHtml);
                            if (obj && Date.now() - obj.t < CACHE_TTL) {
                                out.innerHTML = obj.html; return;
                            }
                        }
                        const rawMd = localStorage.getItem(key);
                        if (rawMd) {
                            const obj = JSON.parse(rawMd);
                            if (obj && Date.now() - obj.t < CACHE_TTL) {
                                // 渲染旧 md（回退解析器或已存在库）
                                renderMarkdown(obj.md);
                                return;
                            }
                        }
                    } catch (e) {}
                }
            })();

            // 渲染（优先使用 marked+DOMPurify）
            function renderMarkdown(md) {
                const job = () => {
                    try {
                        if (window.marked && window.DOMPurify) {
                            const html = window.marked.parse(md || '');
                            out.innerHTML = window.DOMPurify.sanitize(html);
                        } else {
                            out.innerHTML = simpleMdToHtml(md || '');
                        }
                        out.querySelectorAll('img').forEach(img => { img.loading='lazy'; img.decoding='async'; img.style.maxWidth='100%'; });
                    } catch (e) { showMsg('渲染失败：' + (e && e.message || e), 'err'); }
                };
                if ('requestIdleCallback' in window) requestIdleCallback(job, { timeout: 500 }); else setTimeout(job, 50);
            }

            // 保存缓存（md 与 可选已消毒 html）
            function saveCache(url, md, sanitizedHtml, meta) {
                try {
                    localStorage.setItem(keyFor(url), JSON.stringify({ t: Date.now(), md }));
                    if (sanitizedHtml) localStorage.setItem(htmlKeyFor(url), JSON.stringify({ t: Date.now(), html: sanitizedHtml }));
                    if (meta) localStorage.setItem(metaKeyFor(url), JSON.stringify(meta));
                } catch (e) {}
            }

            // 从缓存读取 md/html/meta
            function readCache(url) {
                try {
                    const mdRaw = localStorage.getItem(keyFor(url));
                    const htmlRaw = localStorage.getItem(htmlKeyFor(url));
                    const metaRaw = localStorage.getItem(metaKeyFor(url));
                    return {
                        md: mdRaw ? JSON.parse(mdRaw).md : null,
                        html: htmlRaw ? JSON.parse(htmlRaw).html : null,
                        meta: metaRaw ? JSON.parse(metaRaw) : null
                    };
                } catch(e){ return {md:null,html:null,meta:null}; }
            }

            // 带条件头的 fetch：If-None-Match / If-Modified-Since，实现 304 优化
            async function fetchWithConditional(url, timeout = FETCH_TIMEOUT) {
                const cached = readCache(url);
                const headers = {};
                if (cached.meta && cached.meta.etag) headers['If-None-Match'] = cached.meta.etag;
                if (cached.meta && cached.meta.lastModified) headers['If-Modified-Since'] = cached.meta.lastModified;

                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), timeout);
                try {
                    const res = await fetch(url, { cache: 'no-cache', headers, signal: controller.signal });
                    clearTimeout(timer);
                    if (res.status === 304) {
                        return { url, status:304, md: cached.md, html: cached.html, meta: cached.meta };
                    }
                    if (!res.ok) throw new Error('status ' + res.status);
                    const text = await res.text();
                    const meta = { etag: res.headers.get('ETag'), lastModified: res.headers.get('Last-Modified') };
                    return { url, status: res.status, md: text, meta };
                } catch (e) {
                    clearTimeout(timer);
                    throw e;
                }
            }

            // 并行发起多个 candidates，取第一个成功（支持 200 与 304）
            async function fetchFirst(candidates) {
                const attempts = candidates.map(c => fetchWithConditional(c).then(r => ({ok:true, res:r})).catch(e => ({ok:false, err:e})));
                // Promise.any 优先（返回第一个 fulfilled），否则自实现
                if (Promise.any) {
                    const settled = await Promise.any(attempts);
                    if (settled.ok) return settled.res;
                    throw new Error('no success');
                } else {
                    return new Promise((resolve, reject) => {
                        let rejs=0, errs=[];
                        attempts.forEach(p => p.then(r => {
                            if (r.ok) resolve(r.res);
                            else { rejs++; errs.push(r.err); if (rejs===attempts.length) reject(errs); }
                        }).catch(err => { rejs++; errs.push(err); if (rejs===attempts.length) reject(errs); }));
                    });
                }
            }

            // 主加载流程：并行获取最新（条件请求），若 200 则解析并缓存 html（若有库）
            async function tryLoadAll(force=false) {
                if (location.protocol === 'file:' && !force) {
                    showMsg('file:// 协议受限。请用 HTTP 服务器（例如 python -m http.server）或允许刷新以强制尝试云端。', 'err');
                    return;
                }

                try {
                    const res = await fetchFirst(candidates);
                    if (!res) throw new Error('no result');
                    // 如果 304 且有缓存 html 可直接用，否则渲染 md 并缓存
                    if (res.status === 304) {
                        if (res.html) out.innerHTML = res.html;
                        else renderMarkdown(res.md || '');
                        return;
                    }
                    // 200：新内容
                    const md = res.md || '';
                    // 若标记了第三方库，则生成 sanitized html 并缓存；否则仅缓存 md
                    if (window.marked && window.DOMPurify) {
                        try {
                            const html = window.marked.parse(md || '');
                            const sanitized = window.DOMPurify.sanitize(html);
                            saveCache(res.url, md, sanitized, res.meta);
                            out.innerHTML = sanitized;
                        } catch (e) {
                            saveCache(res.url, md, null, res.meta);
                            renderMarkdown(md);
                        }
                    } else {
                        saveCache(res.url, md, null, res.meta);
                        renderMarkdown(md);
                    }
                } catch (e) {
                    // 并行失败：回退逐个尝试（兼容旧浏览器/网络）
                    for (const url of candidates) {
                        try {
                            const r = await fetchWithConditional(url).catch(()=>null);
                            if (!r) continue;
                            if (r.status === 304) {
                                if (r.html) { out.innerHTML = r.html; return; }
                                renderMarkdown(r.md || ''); return;
                            } else {
                                const md = r.md || '';
                                if (window.marked && window.DOMPurify) {
                                    try {
                                        const html = window.marked.parse(md || '');
                                        const sanitized = window.DOMPurify.sanitize(html);
                                        saveCache(r.url, md, sanitized, r.meta);
                                        out.innerHTML = sanitized; return;
                                    } catch (e2) {
                                        saveCache(r.url, md, null, r.meta);
                                        renderMarkdown(md); return;
                                    }
                                } else {
                                    saveCache(r.url, md, null, r.meta);
                                    renderMarkdown(md); return;
                                }
                            }
                        } catch (e2) { /* try next */ }
                    }
                    showMsg('未能加载名单（网络/文件不存在）。请检查文件或启动 HTTP 服务。', 'err');
                }
            }

            // 在后台加载 marked/DOMPurify（不阻塞首屏）
            (async function loadLibs() {
                try {
                    await Promise.allSettled([
                        window.marked ? Promise.resolve() : loadScript('https://cdn.jsdelivr.net/npm/marked/marked.min.js'),
                        window.DOMPurify ? Promise.resolve() : loadScript('https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js')
                    ]);
                } catch (e) {}
            })();

            // 插入刷新按钮（手动强制刷新）
            (function insertRefresh() {
                try {
                    const container = document.querySelector('.container');
                    if (!container) return;
                    const btn = document.createElement('button');
                    btn.textContent = '刷新名单';
                    btn.style.margin = '12px 0';
                    btn.className = 'th2';
                    btn.onclick = () => {
                        showMsg('正在刷新……', 'warn');
                        // 强制忽略缓存元数据，直接请求最新（通过在 URL 后追加随机参数）
                        const forced = candidates.map(u => (u + (u.includes('?') ? '&' : '?') + '_=' + Date.now()));
                        // 临时调用 fetchFirst with forced urls
                        (async () => {
                            try {
                                const res = await fetchFirst(forced);
                                if (res && res.md) {
                                    // 使用 forced URL，保存到原始 url 的缓存位置（使用 forced->original mapping not provided: simply save under forced key)
                                    // 为简单起见，保存到 first original candidate key if exists
                                    const targetKey = candidates[0] || res.url;
                                    if (window.marked && window.DOMPurify) {
                                        const html = window.marked.parse(res.md || '');
                                        const sanitized = window.DOMPurify.sanitize(html);
                                        saveCache(targetKey, res.md, sanitized, res.meta || null);
                                        out.innerHTML = sanitized;
                                    } else {
                                        saveCache(targetKey, res.md, null, res.meta || null);
                                        renderMarkdown(res.md || '');
                                    }
                                    showMsg('刷新完成', 'warn');
                                } else showMsg('刷新未获取到内容', 'err');
                            } catch (err) { showMsg('刷新失败：' + (err.message||err), 'err'); }
                        })();
                    };
                    container.insertBefore(btn, container.children[1] || null);
                } catch (e) {}
            })();

            // 立即触发加载（stale-while-revalidate：先用缓存，背景取最新）
            tryLoadAll().catch(e => console.error(e));

        })();
        </script>
    </body>
</html>
